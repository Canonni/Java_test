&emsp;&emsp;写在前面：本系列围绕《剑指offer》这本书中编程题目，均用java编写，不过我的书落在学校了ヽ(ー_ー)ノ，最近就在牛客网上刷一刷[剑指offer编程题](https://www.nowcoder.com/ta/coding-interviews)。信息学院学生中的小白一枚，如果写的不对的地方，请各位批评指正~
___
## 题目描述
输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。
 ### 思路1：逻辑与运算
&emsp;&emsp;计算机中的有符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。 在计算机系统中，数值一律用补码来表示和存储。
+ 原码：是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值；
+ 反码：正数的反码是其本身，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反
+ 补码：正数的补码就是其本身，负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后+1。（即在反码的基础上+1）

十进制 |原码 | 反码 | 补码
|:---:|:---:|:---:|:---:|
1|00000001|00000001|00000011|
3|00000011|00000011|00000011|
-1|10000001|11111110|11111111|
-5|10000101|11111010|11111011|
-7|10000111|11111000|11111001|
+ 正数右移：符号不变，相当于/2。
+ 正数左移：符号不变，相当于*2。
+ 负数右移：符号不变，移位后最高位设为1。如果一直右移，最终会变成-1。（补码为11111111）
+ 负数左移：不保持为负数，在左移的过程中会有正有负的情况。所以切记负数左移不会特殊处理符号位。如果一直左移，最终会变成0。  
则取一个flag=0001，与目标n做逻辑与运算（&），若第一位为1，则与运算的结果不为0，count++；若第一位为0，则与运算的结果为0，count不变。将flag左移一位，即flag=0010，与目标n做逻辑与运算（&），判断第二位是否为1……代码如下
```
public class Solution {
    public int NumberOf1(int n) {
        int num = 0, flag = 1;
        while (flag != 0) {
            if ((n & flag) != 0) {
                num++;
            }
            flag <<= 1;
        }
        return num;
    }

    public static void main(String[] args) {
        Solution s = new Solution();
        System.out.println(s.NumberOf1(3));
        System.out.println(s.NumberOf1(-5));
    }
}
```
 ### 思路2：独特的位运算[^er1]
 [^er1]:[搬运自牛客网:二进制中1的个数](https://www.nowcoder.com/questionTerminal/8ee967e43c2c4ec193b040ea7fbb10b8?f=discussion)
 
&emsp;&emsp;整数n，进行n&(n-1)运算，会把二进制表示中最右边的1变为0。
举个例子：一个二进制数1110，第二位是处于最右边的一个1。减去1后，变成1101，它后面的两位变成了01，而前面的1保持不变。减1的结果就是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1110&1101=1100。  
也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0。那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。
```
public int NumberOf1(int n) {
    int num = 0;
    while (n != 0){
        num++;
        n &= (n-1);
    }
    return num;
}
```